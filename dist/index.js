// @bun
import{OAuth2RequestError as cN,ArcticFetchError as oN}from"arctic";import{Elysia as tN}from"elysia";import{generateState as zN,generateCodeVerifier as PN}from"arctic";import{Elysia as RN}from"elysia";import{AmazonCognito as v,AniList as l,Apple as h,Atlassian as u,Auth0 as c,Authentik as o,Bitbucket as t,Box as s,Coinbase as d,Discord as a,Dribbble as i,Dropbox as e,Facebook as r,Figma as NN,Intuit as EN,GitHub as SN,GitLab as IN,Google as UN,Kakao as mN,KeyCloak as MN,Lichess as TN,Line as xN,Linear as ON,LinkedIn as wN,MicrosoftEntraId as DN,MyAnimeList as $N,Notion as AN,Okta as LN,Osu as HN,Patreon as CN,Reddit as fN,Roblox as nN,Salesforce as JN,Shikimori as QN,Slack as XN,Spotify as YN,Strava as jN,Tiltify as qN,Tumblr as FN,Twitch as WN,Twitter as ZN,VK as BN,WorkOS as gN,Yahoo as pN,Yandex as GN,Zoom as KN,FortyTwo as VN}from"arctic";var q={AmazonCognito:v,AniList:l,Apple:h,Atlassian:u,Auth0:c,Authentik:o,Bitbucket:t,Box:s,Coinbase:d,Discord:a,Dribbble:i,Dropbox:e,Facebook:r,Figma:NN,FortyTwo:VN,GitHub:SN,GitLab:IN,Google:UN,Intuit:EN,Kakao:mN,KeyCloak:MN,Lichess:TN,Line:xN,Linear:ON,LinkedIn:wN,MicrosoftEntraId:DN,MyAnimeList:$N,Notion:AN,Okta:LN,Osu:HN,Patreon:CN,Reddit:fN,Roblox:nN,Salesforce:JN,Shikimori:QN,Slack:XN,Spotify:YN,Strava:jN,Tiltify:qN,Tumblr:FN,Twitch:WN,Twitter:ZN,VK:BN,WorkOS:gN,Yahoo:pN,Yandex:GN,Zoom:KN},g=Object.keys(q).reduce((N,S)=>{return N[S.toLowerCase()]=S,N},{});var Z=(N)=>("refreshAccessToken"in N)&&typeof N.refreshAccessToken==="function",p=(N)=>("revokeAccessToken"in N)&&typeof N.revokeAccessToken==="function",J=(N)=>Object.keys(q).map((S)=>S.toLowerCase()).includes(N.toLowerCase()),G=(N)=>!0,K=(N)=>N!==null&&N!==void 0&&N.trim()!=="";var V=86400000;var F=1800;var z=({clientProviders:N,authorizeRoute:S="authorize",onAuthorize:M})=>new RN().get(`/${S}/:provider`,({error:E,redirect:I,cookie:{state:m,code_verifier:T,auth_provider:U,redirect_url:O},params:{provider:$},headers:A})=>{if($===void 0)return E("Bad Request","Provider is required");if(!J($))return E("Bad Request","Invalid provider");try{let w=$.toLowerCase(),{providerInstance:f,scopes:L,searchParams:D}=N[w],x=A.referer??"/";O.set({httpOnly:!0,maxAge:F,path:"/",sameSite:"lax",secure:!0,value:x}),U.set({httpOnly:!0,maxAge:F,path:"/",sameSite:"lax",secure:!0,value:$});let H=zN();m.set({httpOnly:!0,maxAge:F,path:"/",sameSite:"lax",secure:!0,value:H});let C=f.createAuthorizationURL.toString().includes("codeVerifier"),n=C?PN():void 0;C&&T.set({httpOnly:!0,maxAge:F,path:"/",sameSite:"lax",secure:!0,value:n??""});let Q=C?f.createAuthorizationURL(H,n,L):f.createAuthorizationURL(H,L);return D.forEach(([Y,j])=>{Q.searchParams.set(Y,j)}),M?.(),I(Q.toString())}catch(w){if(w instanceof Error)return E("Internal Server Error",`${w.message} - ${w.stack??""}`);return E("Internal Server Error",`Unknown error: ${w}`)}});import{decodeIdToken as kN}from"arctic";import{Elysia as yN}from"elysia";import{Elysia as bN}from"elysia";var X=()=>{let N={};return new bN({name:"sessionStore"}).state({session:N})};var P=({clientProviders:N,callbackRoute:S="authorize/callback",onCallback:M})=>new yN().use(X()).get(`/${S}`,async({error:E,redirect:I,store:{session:m},cookie:{state:T,code_verifier:U,redirect_url:O,user_session_id:$,auth_provider:A},query:{code:w,state:f}})=>{if(!K(w)||T.value===void 0)return E("Bad Request","Invalid callback request");if(f!==T.value)return E("Bad Request","Invalid state mismatch");if(A.value===void 0)return E("Unauthorized","No auth provider found");if(!J(A.value))return E("Unauthorized","Invalid provider");let L=A.value.toLowerCase(),{providerInstance:D}=N[L];try{T.remove();let x=D.validateAuthorizationCode.toString().includes("codeVerifier"),H=U.value;if(x&&H===void 0)return E("Bad Request","Code verifier not found and is required");let C=H??"",n=await(x?D.validateAuthorizationCode(w,C):D.validateAuthorizationCode(w));if(x)U.remove();let Q=Object.fromEntries(Object.entries(kN(n.idToken())).map(([B,W])=>[B,typeof W==="string"?W:void 0])),Y=A.value;await M?.({authProvider:Y,decodedIdToken:Q,session:m,user_session_id:$});let j=O.value??"/";return I(j)}catch(x){if(x instanceof Error)return E("Internal Server Error",`${x.message} - ${x.stack??""}`);return E("Internal Server Error",`Failed to validate authorization code: Unknown error: ${x}`)}});import{Elysia as _N}from"elysia";var R=({logoutRoute:N="logout",onLogout:S})=>new _N().post(`/${N}`,async({error:M,cookie:{user_session_id:E,auth_provider:I}})=>{if(I.value===void 0)return M("Unauthorized","No auth provider found");try{return S?.(),E.remove(),I.remove(),new Response("Succesfuly Logged Out",{status:204})}catch(m){if(m instanceof Error)return M("Internal Server Error",`Failed to logout: ${m.message}`);return M("Internal Server Error",`Failed to logout: Unknown error: ${m}`)}});import{Elysia as vN}from"elysia";var b=()=>new vN().use(X()).derive(({store:{session:N},cookie:{user_session_id:S},error:M})=>({protectRoute:async(E,I)=>{if(S.value===void 0)return I?.()??M("Unauthorized","No session ID found");if(N[S.value]===void 0)return I?.()??M("Unauthorized","No session found");return E()}})).as("plugin");import{Elysia as lN}from"elysia";var k=({clientProviders:N,refreshRoute:S="refresh",onRefresh:M})=>new lN().post(`/${S}`,async({error:E,cookie:{user_refresh_token:I,auth_provider:m}})=>{if(I.value===void 0)return E("Unauthorized","No refresh token found");if(m.value===void 0)return E("Unauthorized","No auth provider found");let T=m.value.toLowerCase(),{providerInstance:U}=N[T];if(!Z(U))return E("Not Implemented","Provider is not refreshable");try{return await U.refreshAccessToken(I.value),M?.(),new Response("Token refreshed",{status:204})}catch(O){if(O instanceof Error)return E("Internal Server Error",`Failed to refresh token: ${O.message}`);return E("Internal Server Error",`Faile to refresh token: Unknown error: ${O}`)}});import{Elysia as hN}from"elysia";var y=({clientProviders:N,revokeRoute:S="revoke",onRevoke:M})=>new hN().post(`/${S}/access-token`,async({error:E,cookie:{user_refresh_token:I,auth_provider:m}})=>{if(I.value===void 0)return E("Unauthorized","No refresh token found");if(m.value===void 0)return E("Unauthorized","No auth provider found");let T=m.value.toLowerCase(),{providerInstance:U}=N[T];if(!p(U))return E("Not Implemented","Provider does not support revocation");try{return await U.revokeAccessToken(I.value),M?.(),new Response("Token revoked",{status:204})}catch(O){if(O instanceof Error)return E("Internal Server Error",`Failed to revoke token: ${O.message}`);return E("Internal Server Error",`Failed to revoke token: Unknown error: ${O}`)}});import{Elysia as uN}from"elysia";var _=({clientProviders:N,statusRoute:S="auth-status",onStatus:M})=>new uN().use(X()).get(`/${S}`,async({error:E,cookie:{user_session_id:I,auth_provider:m},store:{session:T}})=>{try{if(I.value===void 0)return new Response(JSON.stringify({isLoggedIn:!1,user:null}),{headers:{"Content-Type":"application/json"}});if(m.value===void 0)return new Response(JSON.stringify({isLoggedIn:!1,user:null}),{headers:{"Content-Type":"application/json"}});let U=m.value.toLowerCase(),{providerInstance:O}=N[U];if(!Z(O))return E("Not Implemented","Provider is not refreshable");let $=T[I.value];if($===void 0)return new Response(JSON.stringify({isLoggedIn:!1,user:null}),{headers:{"Content-Type":"application/json"}});let{user:A}=$;return M?.(),new Response(JSON.stringify({isLoggedIn:!0,user:A}),{headers:{"Content-Type":"application/json"}})}catch(U){if(U instanceof Error)return E("Internal Server Error",`Error: ${U.message} - ${U.stack??""}`);return E("Internal Server Error",`Unknown Error: ${U}`)}});var BE=async({authProvider:N,decodedIdToken:S,user_session_id:M,session:E,getUser:I,createUser:m})=>{let T=await I?.({authProvider:N,decodedIdToken:S});if(T=T??await m?.({authProvider:N,decodedIdToken:S}),!G(T))throw new Error("Internal Server Error - Invalid user schema");let U=crypto.randomUUID();E[U]={expiresAt:Date.now()+V,user:T},M.set({httpOnly:!0,sameSite:"lax",secure:!0,value:U})},gE=(N)=>N;var lE=({config:N,authorizeRoute:S,callbackRoute:M,logoutRoute:E,statusRoute:I,refreshRoute:m,revokeRoute:T,onAuthorize:U,onCallback:O,onStatus:$,onRefresh:A,onLogout:w,onRevoke:f})=>{let L=Object.keys(N).reduce((D,x)=>{if(!Object.prototype.hasOwnProperty.call(N,x))return D;if(!J(x))return console.error(`Provider ${x} is not supported`),D;let H=N[x];if(!H)return D;let C=x.toLowerCase(),n=g[C];if(!J(n))return console.error(`Provider ${x} is not supported`),D;let Q=q[n],{credentials:Y,scopes:j=[],searchParams:B=[]}=H,W=new Q(...Y);return D[C]={providerInstance:W,scopes:j,searchParams:B},D},{});return new tN().error("OAUTH2_REQUEST_ERROR",cN).error("ARCTIC_FETCH_ERROR",oN).use(R({logoutRoute:E,onLogout:w})).use(y({clientProviders:L,onRevoke:f,revokeRoute:T})).use(_({clientProviders:L,onStatus:$,statusRoute:I})).use(k({clientProviders:L,onRefresh:A,refreshRoute:m})).use(z({authorizeRoute:S,clientProviders:L,onAuthorize:U})).use(P({callbackRoute:M,clientProviders:L,onCallback:O})).use(b()).as("plugin")};export{BE as instantiateUserSession,gE as createAuthConfig,lE as absoluteAuth};
