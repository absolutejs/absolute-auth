// @bun
import{OAuth2RequestError as cN,ArcticFetchError as tN}from"arctic";import{Elysia as oN}from"elysia";import{generateState as zN,generateCodeVerifier as PN}from"arctic";import{Elysia as RN}from"elysia";import{AmazonCognito as _,AniList as l,Apple as h,Atlassian as u,Auth0 as c,Authentik as t,Bitbucket as o,Box as d,Coinbase as s,Discord as a,Dribbble as i,Dropbox as e,Facebook as r,Figma as NN,Intuit as EN,GitHub as SN,GitLab as IN,Google as UN,Kakao as mN,KeyCloak as MN,Lichess as TN,Line as xN,Linear as ON,LinkedIn as wN,MicrosoftEntraId as DN,MyAnimeList as $N,Notion as AN,Okta as LN,Osu as HN,Patreon as CN,Reddit as fN,Roblox as JN,Salesforce as QN,Shikimori as XN,Slack as YN,Spotify as jN,Strava as qN,Tiltify as FN,Tumblr as WN,Twitch as ZN,Twitter as BN,VK as gN,WorkOS as pN,Yahoo as nN,Yandex as GN,Zoom as KN,FortyTwo as VN}from"arctic";var F={AmazonCognito:_,AniList:l,Apple:h,Atlassian:u,Auth0:c,Authentik:t,Bitbucket:o,Box:d,Coinbase:s,Discord:a,Dribbble:i,Dropbox:e,Facebook:r,Figma:NN,FortyTwo:VN,GitHub:SN,GitLab:IN,Google:UN,Intuit:EN,Kakao:mN,KeyCloak:MN,Lichess:TN,Line:xN,Linear:ON,LinkedIn:wN,MicrosoftEntraId:DN,MyAnimeList:$N,Notion:AN,Okta:LN,Osu:HN,Patreon:CN,Reddit:fN,Roblox:JN,Salesforce:QN,Shikimori:XN,Slack:YN,Spotify:jN,Strava:qN,Tiltify:FN,Tumblr:WN,Twitch:ZN,Twitter:BN,VK:gN,WorkOS:pN,Yahoo:nN,Yandex:GN,Zoom:KN},p=Object.keys(F).reduce((N,S)=>{return N[S.toLowerCase()]=S,N},{});var B=(N)=>("refreshAccessToken"in N)&&typeof N.refreshAccessToken==="function",n=(N)=>("revokeAccessToken"in N)&&typeof N.revokeAccessToken==="function",Q=(N)=>Object.keys(F).map((S)=>S.toLowerCase()).includes(N.toLowerCase()),G=(N)=>!0,K=(N)=>N!==null&&N!==void 0&&N.trim()!=="";var V=86400000;var W=1800;var z=({clientProviders:N,authorizeRoute:S="authorize",onAuthorize:I})=>new RN().get(`/${S}/:provider`,({error:E,redirect:U,cookie:{state:M,code_verifier:T,auth_provider:m,redirect_url:O},params:{provider:w},headers:A})=>{if(w===void 0)return E("Bad Request","Provider is required");if(!Q(w))return E("Bad Request","Invalid provider");try{let D=w.toLowerCase(),{providerInstance:f,scopes:L,searchParams:$}=N[D],x=A.referer??"/";O.set({httpOnly:!0,maxAge:W,path:"/",sameSite:"lax",secure:!0,value:x}),m.set({httpOnly:!0,maxAge:W,path:"/",sameSite:"lax",secure:!0,value:w});let H=zN();M.set({httpOnly:!0,maxAge:W,path:"/",sameSite:"lax",secure:!0,value:H});let C=f.createAuthorizationURL.toString().includes("codeVerifier"),J=C?PN():void 0;C&&T.set({httpOnly:!0,maxAge:W,path:"/",sameSite:"lax",secure:!0,value:J??""});let X=C?f.createAuthorizationURL(H,J,L):f.createAuthorizationURL(H,L);return $.forEach(([j,q])=>{X.searchParams.set(j,q)}),I?.(),U(X.toString())}catch(D){if(D instanceof Error)return E("Internal Server Error",`${D.message} - ${D.stack??""}`);return E("Internal Server Error",`Unknown error: ${D}`)}});import{decodeIdToken as kN}from"arctic";import{Elysia as yN}from"elysia";import{Elysia as bN}from"elysia";var Y=()=>{let N={};return new bN({name:"sessionStore"}).state({session:N})};var P=({clientProviders:N,callbackRoute:S="authorize/callback",onCallback:I})=>new yN().use(Y()).get(`/${S}`,async({error:E,redirect:U,store:{session:M},cookie:{state:T,code_verifier:m,redirect_url:O,user_session_id:w,auth_provider:A},query:{code:D,state:f}})=>{if(!K(D)||T.value===void 0)return E("Bad Request","Invalid callback request");if(f!==T.value)return E("Bad Request","Invalid state mismatch");if(A.value===void 0)return E("Unauthorized","No auth provider found");if(!Q(A.value))return E("Unauthorized","Invalid provider");let L=A.value.toLowerCase(),{providerInstance:$}=N[L];try{T.remove();let x=$.validateAuthorizationCode.toString().includes("codeVerifier"),H=m.value;if(x&&H===void 0)return E("Bad Request","Code verifier not found and is required");let C=H??"",J=await(x?$.validateAuthorizationCode(D,C):$.validateAuthorizationCode(D));if(x)m.remove();let X=Object.fromEntries(Object.entries(kN(J.idToken())).map(([g,Z])=>[g,typeof Z==="string"?Z:void 0])),j=A.value;console.log("in route user_session_id before",w.value),await I?.({authProvider:j,decodedIdToken:X,session:M,user_session_id:w}),console.log("in route user_session_id after",w.value);let q=O.value??"/";return U(q)}catch(x){if(x instanceof Error)return E("Internal Server Error",`${x.message} - ${x.stack??""}`);return E("Internal Server Error",`Failed to validate authorization code: Unknown error: ${x}`)}});import{Elysia as vN}from"elysia";var R=({logoutRoute:N="logout",onLogout:S})=>new vN().post(`/${N}`,async({error:I,cookie:{user_session_id:E,auth_provider:U}})=>{if(U.value===void 0)return I("Unauthorized","No auth provider found");try{return S?.(),E.remove(),U.remove(),new Response("Succesfuly Logged Out",{status:204})}catch(M){if(M instanceof Error)return I("Internal Server Error",`Failed to logout: ${M.message}`);return I("Internal Server Error",`Failed to logout: Unknown error: ${M}`)}});import{Elysia as _N}from"elysia";var b=()=>new _N().use(Y()).derive(({store:{session:N},cookie:{user_session_id:S},error:I})=>({protectRoute:async(E,U)=>{if(S.value===void 0)return U?.()??I("Unauthorized","No session ID found");if(N[S.value]===void 0)return U?.()??I("Unauthorized","No session found");return E()}})).as("plugin");import{Elysia as lN}from"elysia";var k=({clientProviders:N,refreshRoute:S="refresh",onRefresh:I})=>new lN().post(`/${S}`,async({error:E,cookie:{user_refresh_token:U,auth_provider:M}})=>{if(U.value===void 0)return E("Unauthorized","No refresh token found");if(M.value===void 0)return E("Unauthorized","No auth provider found");let T=M.value.toLowerCase(),{providerInstance:m}=N[T];if(!B(m))return E("Not Implemented","Provider is not refreshable");try{return await m.refreshAccessToken(U.value),I?.(),new Response("Token refreshed",{status:204})}catch(O){if(O instanceof Error)return E("Internal Server Error",`Failed to refresh token: ${O.message}`);return E("Internal Server Error",`Faile to refresh token: Unknown error: ${O}`)}});import{Elysia as hN}from"elysia";var y=({clientProviders:N,revokeRoute:S="revoke",onRevoke:I})=>new hN().post(`/${S}/access-token`,async({error:E,cookie:{user_refresh_token:U,auth_provider:M}})=>{if(U.value===void 0)return E("Unauthorized","No refresh token found");if(M.value===void 0)return E("Unauthorized","No auth provider found");let T=M.value.toLowerCase(),{providerInstance:m}=N[T];if(!n(m))return E("Not Implemented","Provider does not support revocation");try{return await m.revokeAccessToken(U.value),I?.(),new Response("Token revoked",{status:204})}catch(O){if(O instanceof Error)return E("Internal Server Error",`Failed to revoke token: ${O.message}`);return E("Internal Server Error",`Failed to revoke token: Unknown error: ${O}`)}});import{Elysia as uN}from"elysia";var v=({clientProviders:N,statusRoute:S="auth-status",onStatus:I})=>new uN().use(Y()).get(`/${S}`,async({error:E,cookie:{user_session_id:U,auth_provider:M},store:{session:T}})=>{try{if(U.value===void 0)return new Response(JSON.stringify({isLoggedIn:!1,user:null}),{headers:{"Content-Type":"application/json"}});if(M.value===void 0)return new Response(JSON.stringify({isLoggedIn:!1,user:null}),{headers:{"Content-Type":"application/json"}});let m=M.value.toLowerCase(),{providerInstance:O}=N[m];if(!B(O))return E("Not Implemented","Provider is not refreshable");let w=T[U.value];if(w===void 0)return new Response(JSON.stringify({isLoggedIn:!1,user:null}),{headers:{"Content-Type":"application/json"}});let{user:A}=w;return I?.(),new Response(JSON.stringify({isLoggedIn:!0,user:A}),{headers:{"Content-Type":"application/json"}})}catch(m){if(m instanceof Error)return E("Internal Server Error",`Error: ${m.message} - ${m.stack??""}`);return E("Internal Server Error",`Unknown Error: ${m}`)}});var gE=async({authProvider:N,decodedIdToken:S,user_session_id:I,session:E,getUser:U,createUser:M})=>{let T=await U?.({authProvider:N,decodedIdToken:S});if(T=T??await M?.({authProvider:N,decodedIdToken:S}),!G(T))throw new Error("Internal Server Error - Invalid user schema");let m=crypto.randomUUID();E[m]={expiresAt:Date.now()+V,user:T},console.log("in func user_session_id before set",I.value),I.set({httpOnly:!0,sameSite:"lax",secure:!0,value:m}),console.log("in func user_session_id after set",I.value)},pE=(N)=>N;var lE=({config:N,authorizeRoute:S,callbackRoute:I,logoutRoute:E,statusRoute:U,refreshRoute:M,revokeRoute:T,onAuthorize:m,onCallback:O,onStatus:w,onRefresh:A,onLogout:D,onRevoke:f})=>{let L=Object.keys(N).reduce(($,x)=>{if(!Object.prototype.hasOwnProperty.call(N,x))return $;if(!Q(x))return console.error(`Provider ${x} is not supported`),$;let H=N[x];if(!H)return $;let C=x.toLowerCase(),J=p[C];if(!Q(J))return console.error(`Provider ${x} is not supported`),$;let X=F[J],{credentials:j,scopes:q=[],searchParams:g=[]}=H,Z=new X(...j);return $[C]={providerInstance:Z,scopes:q,searchParams:g},$},{});return new oN().error("OAUTH2_REQUEST_ERROR",cN).error("ARCTIC_FETCH_ERROR",tN).use(R({logoutRoute:E,onLogout:D})).use(y({clientProviders:L,onRevoke:f,revokeRoute:T})).use(v({clientProviders:L,onStatus:w,statusRoute:U})).use(k({clientProviders:L,onRefresh:A,refreshRoute:M})).use(z({authorizeRoute:S,clientProviders:L,onAuthorize:m})).use(P({callbackRoute:I,clientProviders:L,onCallback:O})).use(b()).as("plugin")};export{gE as instantiateUserSession,pE as createAuthConfig,lE as absoluteAuth};
