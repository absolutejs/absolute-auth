// @bun
import{OAuth2RequestError as cN,ArcticFetchError as dN}from"arctic";import{Elysia as oN}from"elysia";import{generateState as VN,generateCodeVerifier as zN}from"arctic";import{Elysia as RN}from"elysia";import{AmazonCognito as v,AniList as h,Apple as l,Atlassian as u,Auth0 as c,Authentik as d,Bitbucket as o,Box as t,Coinbase as s,Discord as a,Dribbble as i,Dropbox as e,Facebook as r,Figma as NN,Intuit as EN,GitHub as IN,GitLab as SN,Google as TN,Kakao as UN,KeyCloak as mN,Lichess as MN,Line as xN,Linear as ON,LinkedIn as wN,MicrosoftEntraId as DN,MyAnimeList as $N,Notion as AN,Okta as nN,Osu as LN,Patreon as HN,Reddit as CN,Roblox as fN,Salesforce as JN,Shikimori as QN,Slack as XN,Spotify as YN,Strava as jN,Tiltify as qN,Tumblr as FN,Twitch as WN,Twitter as ZN,VK as BN,WorkOS as gN,Yahoo as pN,Yandex as GN,Zoom as PN,FortyTwo as KN}from"arctic";var q={AmazonCognito:v,AniList:h,Apple:l,Atlassian:u,Auth0:c,Authentik:d,Bitbucket:o,Box:t,Coinbase:s,Discord:a,Dribbble:i,Dropbox:e,Facebook:r,Figma:NN,FortyTwo:KN,GitHub:IN,GitLab:SN,Google:TN,Intuit:EN,Kakao:UN,KeyCloak:mN,Lichess:MN,Line:xN,Linear:ON,LinkedIn:wN,MicrosoftEntraId:DN,MyAnimeList:$N,Notion:AN,Okta:nN,Osu:LN,Patreon:HN,Reddit:CN,Roblox:fN,Salesforce:JN,Shikimori:QN,Slack:XN,Spotify:YN,Strava:jN,Tiltify:qN,Tumblr:FN,Twitch:WN,Twitter:ZN,VK:BN,WorkOS:gN,Yahoo:pN,Yandex:GN,Zoom:PN},g=Object.keys(q).reduce((N,S)=>{return N[S.toLowerCase()]=S,N},{});var Z=(N)=>("refreshAccessToken"in N)&&typeof N.refreshAccessToken==="function",p=(N)=>("revokeAccessToken"in N)&&typeof N.revokeAccessToken==="function",J=(N)=>Object.keys(q).map((S)=>S.toLowerCase()).includes(N.toLowerCase()),G=(N)=>!0,P=(N)=>N!==null&&N!==void 0&&N.trim()!=="";var K=86400000;var F=1800;var V=({clientProviders:N,authorizeRoute:S="authorize",onAuthorize:U})=>new RN().get(`/${S}/:provider`,({error:E,redirect:I,cookie:{state:T,code_verifier:O,auth_provider:m,redirect_url:x},params:{provider:$},headers:A})=>{if($===void 0)return E("Bad Request","Provider is required");if(!J($))return E("Bad Request","Invalid provider");try{let w=$.toLowerCase(),{providerInstance:C,scopes:n,searchParams:D}=N[w],M=A.referer??"/";x.set({httpOnly:!0,maxAge:F,path:"/",sameSite:"lax",secure:!0,value:M}),m.set({httpOnly:!0,maxAge:F,path:"/",sameSite:"lax",secure:!0,value:$});let L=VN();T.set({httpOnly:!0,maxAge:F,path:"/",sameSite:"lax",secure:!0,value:L});let H=C.createAuthorizationURL.toString().includes("codeVerifier"),f=H?zN():void 0;H&&O.set({httpOnly:!0,maxAge:F,path:"/",sameSite:"lax",secure:!0,value:f??""});let Q=H?C.createAuthorizationURL(L,f,n):C.createAuthorizationURL(L,n);return D.forEach(([Y,j])=>{Q.searchParams.set(Y,j)}),U?.(),I(Q.toString())}catch(w){if(w instanceof Error)return E("Internal Server Error",`${w.message} - ${w.stack??""}`);return E("Internal Server Error",`Unknown error: ${w}`)}});import{decodeIdToken as kN}from"arctic";import{Elysia as yN}from"elysia";import{Elysia as bN}from"elysia";var X=()=>{let N={};return new bN({name:"sessionStore"}).state({session:N})};var z=({clientProviders:N,callbackRoute:S="authorize/callback",onCallback:U})=>new yN().use(X()).get(`/${S}`,async({error:E,redirect:I,store:{session:T},cookie:{state:O,code_verifier:m,redirect_url:x,user_session_id:$,auth_provider:A},query:{code:w,state:C}})=>{if(!P(w)||O.value===void 0)return E("Bad Request","Invalid callback request");if(C!==O.value)return E("Bad Request","Invalid state mismatch");if(A.value===void 0)return E("Unauthorized","No auth provider found");if(!J(A.value))return E("Unauthorized","Invalid provider");let n=A.value.toLowerCase(),{providerInstance:D}=N[n];try{O.remove();let M=D.validateAuthorizationCode.toString().includes("codeVerifier"),L=m.value;if(M&&L===void 0)return E("Bad Request","Code verifier not found and is required");let H=L??"",f=await(M?D.validateAuthorizationCode(w,H):D.validateAuthorizationCode(w));if(M)m.remove();let Q=Object.fromEntries(Object.entries(kN(f.idToken())).map(([B,W])=>[B,typeof W==="string"?W:void 0])),Y=A.value;await U?.({authProvider:Y,decodedIdToken:Q,session:T,user_session_id:$});let j=x.value??"/";return I(j)}catch(M){if(M instanceof Error)return E("Internal Server Error",`${M.message} - ${M.stack??""}`);return E("Internal Server Error",`Failed to validate authorization code: Unknown error: ${M}`)}});import{Elysia as _N}from"elysia";var R=({logoutRoute:N="logout",onLogout:S})=>new _N().post(`/${N}`,async({error:U,cookie:{user_session_id:E,auth_provider:I}})=>{if(I.value===void 0)return U("Unauthorized","No auth provider found");try{return S?.(),E.remove(),I.remove(),new Response("Succesfuly Logged Out",{status:204})}catch(T){if(T instanceof Error)return U("Internal Server Error",`Failed to logout: ${T.message}`);return U("Internal Server Error",`Failed to logout: Unknown error: ${T}`)}});import{Elysia as vN}from"elysia";var b=()=>new vN().use(X()).derive(({store:{session:N},cookie:{user_session_id:S},error:U})=>({protectRoute:async(E,I)=>{if(S.value===void 0)return I?.()??U("Unauthorized","No session ID found");if(N[S.value]===void 0)return I?.()??U("Unauthorized","No session found");return E()}})).as("plugin");import{Elysia as hN}from"elysia";var k=({clientProviders:N,refreshRoute:S="refresh",onRefresh:U})=>new hN().post(`/${S}`,async({error:E,cookie:{user_refresh_token:I,auth_provider:T}})=>{if(I.value===void 0)return E("Unauthorized","No refresh token found");if(T.value===void 0)return E("Unauthorized","No auth provider found");let O=T.value.toLowerCase(),{providerInstance:m}=N[O];if(!Z(m))return E("Not Implemented","Provider is not refreshable");try{return await m.refreshAccessToken(I.value),U?.(),new Response("Token refreshed",{status:204})}catch(x){if(x instanceof Error)return E("Internal Server Error",`Failed to refresh token: ${x.message}`);return E("Internal Server Error",`Faile to refresh token: Unknown error: ${x}`)}});import{Elysia as lN}from"elysia";var y=({clientProviders:N,revokeRoute:S="revoke",onRevoke:U})=>new lN().post(`/${S}/access-token`,async({error:E,cookie:{user_refresh_token:I,auth_provider:T}})=>{if(I.value===void 0)return E("Unauthorized","No refresh token found");if(T.value===void 0)return E("Unauthorized","No auth provider found");let O=T.value.toLowerCase(),{providerInstance:m}=N[O];if(!p(m))return E("Not Implemented","Provider does not support revocation");try{return await m.revokeAccessToken(I.value),U?.(),new Response("Token revoked",{status:204})}catch(x){if(x instanceof Error)return E("Internal Server Error",`Failed to revoke token: ${x.message}`);return E("Internal Server Error",`Failed to revoke token: Unknown error: ${x}`)}});import{Elysia as uN}from"elysia";var _=({clientProviders:N,statusRoute:S="auth-status",onStatus:U})=>new uN().use(X()).get(`/${S}`,async({error:E,cookie:{user_session_id:I,auth_provider:T},store:{session:O}})=>{try{if(I.value===void 0)return new Response(JSON.stringify({isLoggedIn:!1,user:null}),{headers:{"Content-Type":"application/json"}});if(T.value===void 0)return new Response(JSON.stringify({isLoggedIn:!1,user:null}),{headers:{"Content-Type":"application/json"}});let m=T.value.toLowerCase(),{providerInstance:x}=N[m];if(!Z(x))return E("Not Implemented","Provider is not refreshable");let $=O[I.value];if($===void 0)return new Response(JSON.stringify({isLoggedIn:!1,user:null}),{headers:{"Content-Type":"application/json"}});let{user:A}=$;return U?.(),new Response(JSON.stringify({isLoggedIn:!0,user:A}),{headers:{"Content-Type":"application/json"}})}catch(m){if(m instanceof Error)return E("Internal Server Error",`Error: ${m.message} - ${m.stack??""}`);return E("Internal Server Error",`Unknown Error: ${m}`)}});var BE=async({user_session_id:N,session:S,getUser:U,createUser:E})=>{let I=await U();if(I=I??await E(),!G(I))throw new Error("Internal Server Error - Invalid user schema");let T=crypto.randomUUID();S[T]={expiresAt:Date.now()+K,user:I},N.set({httpOnly:!0,sameSite:"lax",secure:!0,value:T})},gE=(N)=>N;var hE=({config:N,authorizeRoute:S,callbackRoute:U,logoutRoute:E,statusRoute:I,refreshRoute:T,revokeRoute:O,onAuthorize:m,onCallback:x,onStatus:$,onRefresh:A,onLogout:w,onRevoke:C})=>{let n=Object.keys(N).reduce((D,M)=>{if(!Object.prototype.hasOwnProperty.call(N,M))return D;if(!J(M))return console.error(`Provider ${M} is not supported`),D;let L=N[M];if(!L)return D;let H=M.toLowerCase(),f=g[H];if(!J(f))return console.error(`Provider ${M} is not supported`),D;let Q=q[f],{credentials:Y,scopes:j=[],searchParams:B=[]}=L,W=new Q(...Y);return D[H]={providerInstance:W,scopes:j,searchParams:B},D},{});return new oN().error("OAUTH2_REQUEST_ERROR",cN).error("ARCTIC_FETCH_ERROR",dN).use(R({logoutRoute:E,onLogout:w})).use(y({clientProviders:n,onRevoke:C,revokeRoute:O})).use(_({clientProviders:n,onStatus:$,statusRoute:I})).use(k({clientProviders:n,onRefresh:A,refreshRoute:T})).use(V({authorizeRoute:S,clientProviders:n,onAuthorize:m})).use(z({callbackRoute:U,clientProviders:n,onCallback:x})).use(b()).as("plugin")};export{BE as instantiateUserSession,gE as createAuthConfig,hE as absoluteAuth};
